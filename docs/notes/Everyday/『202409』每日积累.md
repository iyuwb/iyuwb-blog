---
title: 『202409』每日积累
author: 耶温
createTime: 2024/08/30 19:40:11
permalink: /Everyday/zgaxavgq/
---
# 每日积累-每天一道题

> 千里之行，始于足下 

每日学习一点，碎片化学习（算法或者面试题），记录下来，方便查阅。

注意点：
-   学习自己不熟悉或者不熟练的知识点
-   学习别人的优秀代码

## 『01』『算法』『Z 字形变换』

> 将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。比如输入字符串为 "PAYPALISHIRING" 行数为 3 时，排列如下：

```txt
P   A   H   N
A P L S I I G
Y   I   R
```
> 之后，之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如："PAHNAPLSIIGYIR"。

>输入: s = "PAYPALISHIRING", numRows = 3
>输出: "PAHNAPLSIIGYIR"

>输入：s = "PAYPALISHIRING", numRows = 4
>输出："PINALSIGYAHRPI"

我的思路：
-   定义 x y 两个轴，x轴代表行，y轴代表列
-   遍历字符串，根据行数，将字符放到对应的行中
-   最后将每行的字符拼接起来

我的解法：
```js
var convert = function (s, numRows) {
    
    let x = 0, y = 0; // 定义 x y 两个轴，x轴代表行，y轴代表列
    let flag = 0  // 定义一个标志位，用来判断当前是向上移动还是向下移动
    if (numRows === 1) return s; // 如果行数为1，直接返回字符串

    // 定义一个二维数组，用来存放字符
    let data = {}
    for (var i = 0; i < numRows; i++) {
        data[i] = []
    }

    // 循环字符串
    for (var i = 0; i < s.length; i++) {
        data[y][x] = s[i] // 将字符放到对应的行中对应的列中
        if (y == numRows - 1) { // 当Y轴到达最后一行时反转方向
            flag = 1
        } else if (y == 0) { // 当Y轴到达第一行时反转方向
            flag = 0
        }
        if (!flag) {
            y++ // 向下移动
        } else {
            y-- // 向上移动 
            // 只有向上移动的时候 才会移动x轴
            x++ // 向右移动 
        }
    }

    let str = ''
    for (var i = 0; i < numRows; i++) {
        str += data[i].join('') // 将每行的字符拼接起来
    }
    return str // 返回结果 
};

```
精简代码：
```js
var convert = function(s, numRows) {
    if (numRows === 1 || numRows >= s.length) return s; // 无需计算直接返回字符串

    let rows = new Array(numRows).fill(''); // 创建 numRows 行的数组
    let currentRow = 0; // 当前行数
    let goingDown = false; // 方向标志

    for (let char of s) { // 遍历字符串中的每个字符
        rows[currentRow] += char; // 将字符添加到当前行
        if (currentRow === 0 || currentRow === numRows - 1) { 
            goingDown = !goingDown; // 反转方向
        }
        currentRow += goingDown ? 1 : -1; // 根据方向移动行
    }

    return rows.join(''); // 将所有行连接成一个字符串
};
```

## 『02』『算法』『整数反转&字符串转整数』
> 给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。
> 如果反转后整数超过 32 位的有符号整数的范围 [−2^ 31, 2^ 31 − 1] ，就返回 0。
> 假设环境不允许存储 64 位整数（有符号或无符号）。

> 输入：x = 123
> 输出：321

> 输入：x = -123
> 输出：-321

> 输入：x = 120
> 输出：21


我的思路：
-   将整数转换为字符串
-   将字符串反转
-   将反转后的字符串转换为整数
-   判断整数是否在范围内

我的解法：
```js
var reverse = function(x) {
    let xStr = x.toString(); // 将数字转换为字符串
    let result = ""; // 初始化结果字符串
    if (xStr[0] === "-") { // 如果数字是负数
        result = "-"; // 结果字符串添加负号
        xStr = xStr.slice(1); // 去掉负号
    }    
    
    for (let i = xStr.length - 1; i >= 0; i--) { // 从字符串末尾开始循环
        result += xStr[i]; // 将每个字符添加到结果字符串中
    }
    // 或者  result += xStr.split('').reverse().join('');
    // 判断结果是否超出范围，如果超出范围则返回0，否则返回结果
    return Number(result) > Math.pow(2, 31) - 1 || Number(result) < Math.pow(-2, 31) ? 0 : Number(result); 
};
```
2. 字符串转整数

> 实现一个函数，使其能将字符串转换成一个 32 位有符号整数。
> 输入字符串可以在前面或者后面包含多余的空格，但是反转后的整数不能包含前导零，除非这个整数是零本身。
> 如果整数超过 32 位的有符号整数的范围 [−2^ 31, 2^ 31 − 1] ，就返回范围最大最小。

> 输入："42"
> 输出：42

> 输入："   -042"
> 输出：-42

> 输入："4193 with words"
> 输出：4193

直接借助 `parseInt` 方法实现：

```js
var myAtoi = function (s) {
    let a = parseInt(s) || 0 // parseInt() 函数解析一个字符串参数，并返回一个指定基数的整数。
    if (a > Math.pow(2, 31) - 1) return Math.pow(2, 31) - 1 // 如果 a 大于 2^31 - 1，则返回 2^31 - 1
    else if (a < Math.pow(-2, 31)) return Math.pow(-2, 31) // 如果 a 小于 -2^31，则返回 -2^31
    else return a // 否则返回 a
};
```

## 『03』『算法』『回文数』
> 给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。回文数
是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

进阶：不将整数转为字符串

> 输入：x = 121
> 输出：true

> 输入：x = -121
> 输出：false
> 解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。

> 输入：x = 10
> 输出：false
> 解释：从右向左读, 为 01 。因此它不是一个回文数。

我的思路：
    -   利用 `%` 和 `/` 方法，将整数反转
    -   判断反转后的整数是否与原整数相等

我的解法：
```js
var isPalindrome = function (x) {
    if (x < 0) return false // 负数一定不是回文数
    if (x >= 0 && x < 10) return true // 0-9的数字一定是回文数
    let y = 0; // 用来存放x的反转数
    while (x >= 10) { // 当x大于10时，循环
        y = (y * 10) + (x % 10) // 将x的个位数加到y上
        if (!y) return false // 如果y为0，说明x的个位数是0，那么x一定不是回文数
        // 这里因为需要区分 数字位数为奇数和偶数的情况，所以需要判断一下
        if (x == y) return true // 如果x等于y，说明x是回文数
        x = Math.floor(x / 10) // 将x的个位数去掉
        if (x == y) return true // 如果x等于y，说明x是回文数
    }
    return false
}
```
## 『04』『面试』『检测元素之外的点击』

> 在一个页面中，当用户点击页面上的某个元素时，如何检测用户是否点击了该元素之外的区域？

使用 DOM 的 `contains` 方法，该方法可以检测一个元素是否包含另一个元素。

```js
document.addEventListener('click', function(event) {
    var target = event.target; // 获取点击的元素
    var element = document.getElementById('myElement'); // 获取需要检测的元素
    if (!element.contains(target)) {
        // 如果点击的元素不在需要检测的元素内，则执行相应的操作
        console.log('点击了元素之外的区域');
    }
});
```

## 『05』『面试』『时间复杂度』

> 时间复杂度是衡量算法运行时间的一种方法，它描述了算法运行时间随输入规模增长的变化趋势。

时间复杂度通常用大O符号表示，例如`O(1)`、`O(log n)`、`O(n)`、`O(n log n)`、`O(n^2)`、`O(2^n)`等。
时间复杂度越高，算法的运行时间越长，因此需要尽量选择时间复杂度低的算法。

常见的时间复杂度有：

- `O(1)` ：常数时间复杂度，表示算法的运行时间不随输入规模增长。例如，访问数组中的某个元素。

- `O(log n)` ：对数时间复杂度，表示算法的运行时间随输入规模的对数增长。例如，二分查找。


```js
// 二分查找
function binarySearch(arr, target) {
    let left = 0;
    let right = arr.length - 1;
    while (left <= right) {
        let mid = Math.floor((left + right) / 2);
        if (arr[mid] === target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return -1;
}
```
- `O(n)` ：线性时间复杂度，表示算法的运行时间随输入规模线性增长。例如，遍历数组，单次循环。

- `O(n log n)` ：线性对数时间复杂度，表示算法的运行时间随输入规模的对数线性增长。例如，快速排序。
```js
// 快速排序
function quickSort(arr) {
    if (arr.length <= 1) {
        return arr;
    }
    let pivot = arr[Math.floor(arr.length / 2)];
    let left = [];
    let right = [];
    for (let i = 0; i < arr.length; i++) {
        if (i !== Math.floor(arr.length / 2)) {
            if (arr[i] < pivot) {
                left.push(arr[i]);
            } else {
                right.push(arr[i]);
            }
        }
    }
    return [...quickSort(left), pivot, ...quickSort(right)];
}
```

- `O(n^2)` ：平方时间复杂度，表示算法的运行时间随输入规模的平方增长。例如，选择排序，嵌套循环。

```js
// 选择排序
function selectionSort(arr) {
    for (let i = 0; i < arr.length - 1; i++) {
        let minIndex = i;
        for (let j = i + 1; j < arr.length; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        if (minIndex !== i) {
            let temp = arr[i];
            arr[i] = arr[minIndex];
            arr[minIndex] = temp;
        }
    }
    return arr;
}
```

- `O(2^n)` ：指数时间复杂度，表示算法的运行时间随输入规模的指数增长。例如，斐波那契数列，递归方法。

```js
// 递归  斐波那契数列
function fibonacci(n) {
    if (n <= 1) {
        return n;
    }
    return fibonacci(n - 1) + fibonacci(n - 2);
}
```
## 『06』『面试』『重排和重绘』




