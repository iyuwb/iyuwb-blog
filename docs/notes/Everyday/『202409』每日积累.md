---
title: 『202409』每日积累
author: 耶温
createTime: 2024/08/30 19:40:11
permalink: /Everyday/zgaxavgq/
---
# 每日积累-每天一道题

> 千里之行，始于足下 

每日学习一点，碎片化学习（算法或者面试题），记录下来，方便查阅。

注意点：
-   学习自己不熟悉或者不熟练的知识点
-   学习别人的优秀代码

## 『01』『算法』『Z 字形变换』

> 将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。比如输入字符串为 "PAYPALISHIRING" 行数为 3 时，排列如下：

```txt
P   A   H   N
A P L S I I G
Y   I   R
```
> 之后，之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如："PAHNAPLSIIGYIR"。

>输入: s = "PAYPALISHIRING", numRows = 3
>输出: "PAHNAPLSIIGYIR"

>输入：s = "PAYPALISHIRING", numRows = 4
>输出："PINALSIGYAHRPI"

我的思路：
-   定义 x y 两个轴，x轴代表行，y轴代表列
-   遍历字符串，根据行数，将字符放到对应的行中
-   最后将每行的字符拼接起来

我的解法：
```js
var convert = function (s, numRows) {
    
    let x = 0, y = 0; // 定义 x y 两个轴，x轴代表行，y轴代表列
    let flag = 0  // 定义一个标志位，用来判断当前是向上移动还是向下移动
    if (numRows === 1) return s; // 如果行数为1，直接返回字符串

    // 定义一个二维数组，用来存放字符
    let data = {}
    for (var i = 0; i < numRows; i++) {
        data[i] = []
    }

    // 循环字符串
    for (var i = 0; i < s.length; i++) {
        data[y][x] = s[i] // 将字符放到对应的行中对应的列中
        if (y == numRows - 1) { // 当Y轴到达最后一行时反转方向
            flag = 1
        } else if (y == 0) { // 当Y轴到达第一行时反转方向
            flag = 0
        }
        if (!flag) {
            y++ // 向下移动
        } else {
            y-- // 向上移动 
            // 只有向上移动的时候 才会移动x轴
            x++ // 向右移动 
        }
    }

    let str = ''
    for (var i = 0; i < numRows; i++) {
        str += data[i].join('') // 将每行的字符拼接起来
    }
    return str // 返回结果 
};

```
精简代码：
```js
var convert = function(s, numRows) {
    if (numRows === 1 || numRows >= s.length) return s; // 无需计算直接返回字符串

    let rows = new Array(numRows).fill(''); // 创建 numRows 行的数组
    let currentRow = 0; // 当前行数
    let goingDown = false; // 方向标志

    for (let char of s) { // 遍历字符串中的每个字符
        rows[currentRow] += char; // 将字符添加到当前行
        if (currentRow === 0 || currentRow === numRows - 1) { 
            goingDown = !goingDown; // 反转方向
        }
        currentRow += goingDown ? 1 : -1; // 根据方向移动行
    }

    return rows.join(''); // 将所有行连接成一个字符串
};
```

## 『02』『算法』『整数反转&字符串转整数』
> 给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。
> 如果反转后整数超过 32 位的有符号整数的范围 [−2^ 31, 2^ 31 − 1] ，就返回 0。
> 假设环境不允许存储 64 位整数（有符号或无符号）。

> 输入：x = 123
> 输出：321

> 输入：x = -123
> 输出：-321

> 输入：x = 120
> 输出：21


我的思路：
-   将整数转换为字符串
-   将字符串反转
-   将反转后的字符串转换为整数
-   判断整数是否在范围内

我的解法：
```js
var reverse = function(x) {
    let xStr = x.toString(); // 将数字转换为字符串
    let result = ""; // 初始化结果字符串
    if (xStr[0] === "-") { // 如果数字是负数
        result = "-"; // 结果字符串添加负号
        xStr = xStr.slice(1); // 去掉负号
    }    
    
    for (let i = xStr.length - 1; i >= 0; i--) { // 从字符串末尾开始循环
        result += xStr[i]; // 将每个字符添加到结果字符串中
    }
    // 或者  result += xStr.split('').reverse().join('');
    // 判断结果是否超出范围，如果超出范围则返回0，否则返回结果
    return Number(result) > Math.pow(2, 31) - 1 || Number(result) < Math.pow(-2, 31) ? 0 : Number(result); 
};
```
2. 字符串转整数

> 实现一个函数，使其能将字符串转换成一个 32 位有符号整数。
> 输入字符串可以在前面或者后面包含多余的空格，但是反转后的整数不能包含前导零，除非这个整数是零本身。
> 如果整数超过 32 位的有符号整数的范围 [−2^ 31, 2^ 31 − 1] ，就返回范围最大最小。

> 输入："42"
> 输出：42

> 输入："   -042"
> 输出：-42

> 输入："4193 with words"
> 输出：4193

直接借助 `parseInt` 方法实现：
```js
var myAtoi = function (s) {
    let a = parseInt(s) || 0 // parseInt() 函数解析一个字符串参数，并返回一个指定基数的整数。
    if (a > Math.pow(2, 31) - 1) return Math.pow(2, 31) - 1 // 如果 a 大于 2^31 - 1，则返回 2^31 - 1
    else if (a < Math.pow(-2, 31)) return Math.pow(-2, 31) // 如果 a 小于 -2^31，则返回 -2^31
    else return a // 否则返回 a
};
```




