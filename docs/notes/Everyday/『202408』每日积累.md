---
title: 『202408』每日积累
author: 耶温
createTime: 2024/08/22 20:43:26
permalink: /Everyday/9f99tw4t/
---
# 每日积累-每天一道题

> 千里之行，始于足下 

每日学习一点，碎片化学习（算法或者面试题），记录下来，方便查阅。

注意点：
-   学习自己不熟悉或者不熟练的知识点
-   学习别人的优秀代码

## 『22』『算法』『两数之和』

> 给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

我的思路：

-  遍历数组，查看当前数组是否存在 `target - nums[i]` 的值
-  如果存在，返回下标

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
    // 循环遍历数组
    for (let i = 0; i < nums.length; i++) {
        // 查看是否存在 target - nums[i] 的值
        let num = target - nums[i]
        // 这里需要注意 i+1 是因为 i 之前的已经遍历过了
        if (nums.includes(num,i+1)) {
            // 这里需要注意 nums.includes(num,i+1) 是因为 nums 可能存在重复的元素
            return [i, nums.indexOf(num, i + 1)]
        }
    }
    // 如果没有找到，返回空数组
    return []
};
```
最快解法：

```js
const twoSum = (nums, target) => {
    //创建一个对象 存储出现过的数字，和对应的索引
    const prevNums = {};
    for (let i = 0; i < nums.length; i++) {
        // 储存当前项      
        const curNum = nums[i];
        // 获取目标差值 target - nums[i]                 
        const targetNum = target - curNum;
        // 在prevNums中获取目标的索引        
        const targetNumIndex = prevNums[targetNum]; // 使用对象的方式储存，获取值会更快
        // 如果存在，直接返回 [目标元素的索引,当前索引]      
        if (targetNumIndex !== undefined) {
            return [targetNumIndex, i];
        } else {
            // 如果不存在，说明之前没出现过目标元素  
            // 存入当前的元素和对应的索引                      
            prevNums[curNum] = i;
        }
    }
}
//   作者：笨猪爆破组
//   链接：https://leetcode.cn/problems/two-sum/solutions/301539/qing-xi-de-bian-liang-ming-ming-bang-zhu-ji-yi-bu-/
//   来源：力扣（LeetCode）
//   著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



## 『23』『面试』『0.1 + 0.2』

浮点数：在 JavaScript 中，浮点数是通过 Number 类型来表示的。JavaScript 使用 IEEE 754 标准的双精度浮点数格式，这意味着它可以表示非常大的数和非常小的数，但在进行浮点数运算时可能会遇到精度问题。

1. 浮点数表示范围
```js
// 表示可以安全使用的整数范围。
console.log(Number.MAX_SAFE_INTEGER)
console.log(Number.MIN_SAFE_INTEGER)

// 表示最大值和最小值
console.log(Number.MAX_VALUE) // 1.7976931348623157e+308
console.log(Number.MIN_VALUE) // 5e-324
```

2. 浮点数的精度问题

```js
console.log(0.1 + 0.2)  // 输出 0.30000000000000004
```
解决方案：
-   可以使用`toFixed()`方法格式化浮点数。需要注意的是`toFixed()`方法会四舍五入，所以可能会有精度问题。而且转换之后是字符串类型。需要在需要时再转换为数字类型。

```js
let a = 0.1 + 0.2
console.log(a.toFixed(1))  // 输出 '0.3'
a = parseFloat(a.toFixed(1)) 
console.log(a) // 输出 0.3
```
-   再进行计算时，可以将浮点数转换为整数进行计算，然后再转换回浮点数。

```js
let a = 0.1;
let b = 0.2;
let sum = (a * 10 + b * 10) / 10; // 先乘以 10 再除以 10
console.log(sum); // 输出 0.3
```


3. 浮点数计算封装方法

我们可以封装一个浮点数计算的方法，将浮点数转换为整数进行计算，然后再转换回浮点数。

```js
    (function (global) {

        // 获取小数位数
        function getDecimalLength(num) {
            const str = num.toString();
            const dotIndex = str.indexOf('.');
            return dotIndex === -1 ? 0 : str.length - dotIndex - 1;
        }

        // 获取 所乘数
        function getFactor(a, b) {
            const factorA = getDecimalLength(a);
            const factorB = getDecimalLength(b);
            return Math.pow(10, Math.max(factorA, factorB));
        }

        const FloatMath = {
            add: function (a, b) {
                const factor = getFactor(a, b)
                return (a * factor + b * factor) / factor;
            },

            subtract: function (a, b) {
                const factor = getFactor(a, b)
                return (a * factor - b * factor) / factor;
            },

            multiply: function (a, b) {
                const factor = getFactor(a, b)
                return (a * factor) * (b * factor) / (factor * factor);
            },

            divide: function (a, b) {
                const factor = getFactor(a, b)
                return (a * factor) / (b * factor);
            },
        };

        // 将插件暴露到全局对象
        global.FloatMath = FloatMath;

    })(this);
```
测试使用

```js
    console.log(FloatMath.add(0.1, 0.2)); // 0.3
    console.log(FloatMath.add(1, 0.2)); // 1.2
    console.log(FloatMath.add(1, 0.233333)); // 1.233333
    console.log(FloatMath.add(0.1, 0.222));// 0.322
    console.log(FloatMath.subtract(0.3, 0.111));// 0.189
    console.log(FloatMath.subtract(0.3, 2));// -1.7
    console.log(FloatMath.multiply(0.1, 0.2));// 0.02
    console.log(FloatMath.multiply(0.1, 10));// 1
    console.log(FloatMath.multiply(0.5, 0.8));// 0.4
    console.log(FloatMath.divide(0.3, 1));// 0.3
    console.log(FloatMath.divide(0.1, 0.31));// 0.3225806451612903
    console.log(FloatMath.divide(100, 1.1)); // 90.9090909090909
```

