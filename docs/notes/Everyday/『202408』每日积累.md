---
title: 『202408』每日积累
author: 耶温
createTime: 2024/08/22 20:43:26
permalink: /Everyday/9f99tw4t/
---
# 每日积累-每天一道题

> 千里之行，始于足下 

每日学习一点，碎片化学习（算法或者面试题），记录下来，方便查阅。

注意点：
-   学习自己不熟悉或者不熟练的知识点
-   学习别人的优秀代码

## 『22』『算法』『两数之和』

> 给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

我的思路：

-  遍历数组，查看当前数组是否存在 `target - nums[i]` 的值
-  如果存在，返回下标

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
    // 循环遍历数组
    for (let i = 0; i < nums.length; i++) {
        // 查看是否存在 target - nums[i] 的值
        let num = target - nums[i]
        // 这里需要注意 i+1 是因为 i 之前的已经遍历过了
        if (nums.includes(num,i+1)) {
            // 这里需要注意 nums.includes(num,i+1) 是因为 nums 可能存在重复的元素
            return [i, nums.indexOf(num, i + 1)]
        }
    }
    // 如果没有找到，返回空数组
    return []
};
```
最快解法：

```js
const twoSum = (nums, target) => {
    //创建一个对象 存储出现过的数字，和对应的索引
    const prevNums = {};
    for (let i = 0; i < nums.length; i++) {
        // 储存当前项      
        const curNum = nums[i];
        // 获取目标差值 target - nums[i]                 
        const targetNum = target - curNum;
        // 在prevNums中获取目标的索引        
        const targetNumIndex = prevNums[targetNum]; // 使用对象的方式储存，获取值会更快
        // 如果存在，直接返回 [目标元素的索引,当前索引]      
        if (targetNumIndex !== undefined) {
            return [targetNumIndex, i];
        } else {
            // 如果不存在，说明之前没出现过目标元素  
            // 存入当前的元素和对应的索引                      
            prevNums[curNum] = i;
        }
    }
}
//   作者：笨猪爆破组
//   链接：https://leetcode.cn/problems/two-sum/solutions/301539/qing-xi-de-bian-liang-ming-ming-bang-zhu-ji-yi-bu-/
//   来源：力扣（LeetCode）
//   著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

